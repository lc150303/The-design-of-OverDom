<img align="middle" src="./imgs/title.png">
  
QQ群：565401831  
游戏介绍及入手请移步：[hoho大佬简书教程](https://www.jianshu.com/p/5431cb7f42d3)  
[系列目录](https://zhuanlan.zhihu.com/p/104412058)  
Version：1.0  
Author：Scorpior

# Screeps 任务设计

## 引言
[OverMind](https://github.com/bencbartlett/Overmind/wiki/Tasks) 中就已经有了内容庞大的任务系统，是谁第一个在 Screeps 
游戏中首先提出任务机制的已经不得而知（有谁知道的可以告诉我），但非常确定的是**任务驱动是 Screeps 中一种非常强大的逻辑控制方式**。

在[运输模式](运输模式b.md)中我已经展示了一种任务驱动的工作方式，本篇打算从个人视角来分析**游戏中有哪些功能可以使用任务驱动**、**任务机制的组成部分**和**不同形式任务的优缺点**。

### 优点
“任务”并不是一个前所未有的概念，具体到编程中其实一个任务就是用一个结构体或者对象把一份工作的信息保存起来，直到这份工作被完成或者不再需要进行。从计算机专业的角度很容易理解，保存数据就意味着**节约了反复计算这个数据的** 
**cpu 消耗**，这是任务驱动的第一个收益。

此外，将数据保存起来后，也就可以按自己的需要共享给任何其他对象或其他模块读取，因此**算出数据的对象和使用数据的对象可以解耦合**。解耦合意味着我们可以根据实时需求而非常方便地**替换**算出数据的对象或使用数据的对象，也意味着**用新功能的对象替换原有对象**同样方便。因此任务驱动让代码可以**根据实时需求灵活改变行为**，还能**节省添加新功能的工作量**，这是任务驱动的第二个收益。

还有一个容易被忽视的点是，多种工作的数据都以任务的形式保存起来后，我们也就可以根据所有这些工作数据来**分析帝国整体状态**，再根据这些状态**灵活调整不同工作的优先级或者工作量**。以各种方式记录游戏数据都可以做到这一点，任务是其中之一，这是任务驱动的第三点收益。

### 任务的粒度
**一个任务**包含了多少功能或者多少动作是一个见仁见智的问题，以运输工作举例，最粗粒度的观念可以把“**运输**”整体看作一个任务，creep 在执行这个任务的过程中要决定当前该取资源还是放资源、去哪里取资源或去哪放资源，这样粒度的任务已经和角色驱动的功能一致了。中细粒度的任务可以把“**运输一种资源**”或者“**运输一趟**”作为一个任务，creep 在任务中不需要切换资源种类或者不需要选择取放地点，任务制的优点开始得到利用。最细粒度的任务一般把“**连续的同一种基本行动**”作为一个任务 ~~（毕竟没有人把行动每 1tick 作为一个任务）~~，因此“移动去目的地”、“取资源”、“放资源”就各是一个任务，OverMind 就采取了这种划分方式。

### 缺点
存储数据有什么缺点呢？你可能要回答占用内存，但在我看来游戏中的[存储空间是用不完的](存储机制.md)，所以让我们来看看其他方面。

首先在我应用中常出现的问题是**给灵活性带来延迟**，比如一个 creep 在执行一个耗时几十 tick 的任务时，临时发生了紧急情况，我们很难调用 creep 先处理新情况而不使原有工作出错，这里的出错主要指的是管理原有工作的逻辑可能没考虑被抢占的情况，代码容易 bug。OverMind 里采取了相当于任务栈的概念来实现中途变更的功能，有关联的任务组成一个调用链，新任务的插入可以视为压栈，creep 每次执行栈顶的任务，执行完成后返回到前一任务继续执行。 可以看出，为了在由缓存数据驱动的逻辑中**增加应变能力**，我们**需要额外增加很复杂的代码逻辑**，这在任务模式的实用中常常难以避免。

任务制中每个 creep 所承担的工作是随时改变的，具体来说就是由当时或之前的发布任务的逻辑决定，我们在看见 bug 时可能已经错过了真正出错的逻辑的运行时间，或者无法得知 creep 在执行谁发布的任务，这都导致**难以 debug**成为任务逻辑的另一个缺点，和多线程或者分布式编程很类似。为了改善这个问题，能采取的方法就是增加记录任务逻辑的运行情况，存储在 Memory 等**不易丢失**的位置（用 creep.say() 第二个参数置为 true 也是一个好方法），增加我们事后找到问题根源的概率（我曾经有个 link 的 bug 观察了一两个月才找到，虽然不是任务机制的问题）。

### 预备知识

#### 源和汇
称需要取出物资的对象为源（源节点），需要放入物资的对象为汇（汇节点）。

#### 事件链
“事件就是等待发布的任务，任务就是正在发生的事件”——我。~~（手动滑稽）~~  
[基本概念](事件链.md)。

## 物流系统：让萌新们开始思考任务
每一大佬都首先是一个萌新，每一个萌新最开始都没有任务系统。那么一个玩家啥时候最可能开始考虑使用任务系统呢？看到这篇文章的各位应该都经历了这个过程——有一天忽然发现搬运物资的工作逻辑写不出来了！这一切的起因都是 dev 让大家的 rcl 升得太快了 ~~（大误）~~，但既然无法改变 dev，我们只能自己解决这个问题。

### 问题描述
无论任务划分的粒度如何，物流问题都由类似的基本定义组成，我们可以先描述这样一些要素：地图上固定分布着数量有限的节点（主要是建筑），每个节点在**某一个时刻**需要取出或者放入**一定量的某种资源**，每个节点之间需要一定的**移动时间**，同时数量有限的运输工随机分布在地图上，每个运输工有一定的**容量**，简化起见认为运输工移动速度相同。  
* 关键要素
    * 地图位置
    * 需求时刻
    * 需求量
    * 资源类型
`

### 任务组成
建立一个任务就是把一些信息**绑定存储**，比如以运输一种资源或者运输一趟作为任务，就是把**一些源节点**、**一些汇节点**和**资源类型**进行绑定，这样的好处是比如在往源走的过程中就可以判断汇节点是否还需要资源，如果无效就可以及时取消任务。这样的坏处是比如在往旧的源走的过程中更近的位置出现了新的源（比如另一个 source 的 container 采满了），由于**源汇节点耦合**而难以最优化利用资源，但是这种小幅的效率损失不妨碍任务机制是完成全局运输工作的优秀机制。
```js 
let task = {
    src: xxx,
    dst: yyy,
    resourceType: RESOURCE_zzz,
    amount: 123
}
```

激进一点的做法是类似细粒度的任务划分那样，把移动、取、放三者独立封装，但是这种随时改变目标的任务**给多 creep 调度带来困难**，因为前述耦合的任务中我们很容易控制不会有2个 creep 做同一件事，而散装任务中为了避免 creep 冲突，我们要么每次变化时都**统一对所有节点进行分配**，要么**登记每个节点被 creep （任务）选取为目标的情况**即类似操作系统资源锁的机制。OverMind 采取的是近似于统一分配所有节点的做法，但按我[运输模式1](运输模式a.md)的思路也可以采取将新节点登记在需求列表里，然后有一个任务选取这个节点作为目标后就从需求列表里删除，这样实现起来容易一些。
```js 
// 用某个方式动态获取目标，或者由其他逻辑修改目标
let task = {
    getSrc: getSrcFromList(){xxx},
    getDst: getDstFromList(){yyy},
    ...
}

// 有需求的建筑
addNodeIntoList(structure, srcOrDst, resourceType, amount);
```

### 核心难点
绝大多数运输工作，包括采能量、采字母矿、连续填 powerSpawn、取出 lab 产物、取出 factory 产物等，都是很容易提前计算工作时间的，我们可以把对应的事件按事件链的方法**登记到定时器（timer）里**，这样我们就可以提前预知未来的任务需求。上面说过，存储的状态信息可以用来规划管理，物流运输中我们主要可以优化 **creep 数量控制**和**运输效率**。

#### 运输工数量控制
众所周知闲置 creep 没活干就是浪费生产 creep 的能量，而运输工不足又会导致房间运作减速，而任务驱动让我们可以很自然地**统计运输需求**从而计算所需运输工数量。一般来说一趟运输工作需要运输工先走到源节点再从源节点走到汇节点，粗略地可以把 **从源到汇的路程×2** 作为运输时长，再考虑上需要搬运的资源量我们可以用 **运输时长×资源量** 来估计**运力需求**。这很容易与每个运输工 **1500tick×部件总容量** 的工作能力对应起来，我们称工作能力为**运力供给**。为了尽快完成运输任务，我们只需要保证所关注时间内的**运力供给大于运力需求**，这里不谈等于有两个原因，一是本来对运力就是估算谈不上精确，二是留有冗余方便应对突发情况。

具体怎么实现呢？首先要进行运力需求统计，用一个数组就可以实现，每个元素是一个时间段（比如500tick）内的运力需求总量，**每个运输事件登记到定时器的同时更新**这个数组，即把这个事件的运力需求加在对应时间的已有量上。对应运力需求，可以再用一个数组统计运力供给，**每次登记一个运输工的出生事件时修改对应时间的供给数据**即可。对于源和汇绑定的运输任务，每个任务被定义时就可以唯一计算运力需求，而对于灵活一点的运输模式就要由调度算法决定运力需求了。

#### 物流调度
Screeps 游戏中的物流问题和现实世界的货运或者外卖送餐问题是高度相似的，我认为在分类上是**实时调度问题+货车路径问题**，它和课本上旅行相关问题不同之处在于每个节点需要被访问的时间是不一致的，就好比外卖店家做好之前骑手去太早是浪费时间。游戏中严格意义上还要考虑运输工剩余 ticksToLive 对能否胜任任务的影响，一般可以在 ticksToLive 少于一定值时 `creep.suicide()` 简化处理。现实中针对相关问题的研究都可以作为游戏算法的参考，甚至你可能努力钻研 Screeps 然后取得突破发表 paper 天降 offer 出任 CEO 赢娶白富美走上人生巅峰 ~~（大误）~~。因为这类问题都是NPC问题，人类目前肯定找不到最优算法，大家的方案都是对问题作各种**简化近似**，而有效的近似策略可以**有很多种**，这里介绍少许思路。

运输工和任务的分配问题也就是运输工和源或汇节点的匹配问题，直觉上可以**分为3类**：**creep 选任务**、**任务选 creep** 和**双方互相选择**。creep 选任务指的是每次有 creep 处于空闲状态时就遍历任务找一个最适合自己的，这种方式一般不考虑给正在工作的 creep 增加任务，而如果有事件注册机制的话可以提前分配未发布的任务（比如正在被填的 container）；任务选 creep 是每次有未被领取的任务时就遍历相关 creep 找一个最适合此任务的，这种方式一般不处理未发布的任务，但可以方便地给正在工作的 creep 添加下一个任务形成“任务链”；双选最灵活也最难写，需要更高的算法能力。

**creep 选任务**时最大的难题是怎么**管理需求时间不同的节点**，比如已经采满的 container 直接赶过去越快越好，而距离20格但是会在 10tick 后装满的 container 其实也需要直接赶过去。当然最简单的方式就是只处理已发布任务，但有能力的话，提前出发去未来的任务地点可以提升资源周转速度。具体实现上可以先检查已发布任务，若没任务则查询事件链找最早要发生的事件，提前移动过去准备。可以形成这样很酷的功能：
> 矿工登记接班 creep 的出生事件   
→ 运输工发现已发布任务都完成了   
→ 运输工查询事件链   
→ 运输工提前领取矿工接班 creep 将消耗的 extension 填充任务   
→ 运输工取了能量走到 extension 旁边等待   
→ 矿工接班 creep 开始生   
→ extension 变空的第一 tick 运输工就开始填充

**任务选 creep** 的难题在于**如何判定最近的可用 creep**，比如一个把能量从 storage 搬运到 powerSpawn 的任务需要找运输工，当前空闲的 creep 都停在较远的 extension 旁边（因为它们最近完成的任务是填 extension），而一个正在把 mineral 运回 storage 的 creep 只差两三格就能完成任务，它刚好会停在 storage 旁边。，因为 creep 的移动都会带来高额的 cpu 开销，为了节约 cpu，此时除了正在闲置的 creep 以外，还应该考虑正在进行任务最后一个阶段的 creep。代码实现上我们可以按任务阶段对 creep 进行区分，就和区分空闲 creep 和正在工作的 creep 类似，任务分配时就可以把所有自己想考虑的 creep 都查看一遍，并且因为正在工作的 creep 的任务还需要执行，我们需要有一定的存储方式来记录这种分配。

**任务和 creep 双向匹配**是 OverMind 采取的做法，他的实现方式可以[自行查看](https://github.com/bencbartlett/Overmind/wiki/The-Logistics-System)。除了他的做法以外，还可以用求图最大匹配的思路来做这个问题，参考[论文](https://segmentfault.com/a/1190000015245815?utm_source=tag-newest)。

## 出生队列：当它需要帮别的房间生产 creep

## powerCreep：技能太多，dev 背锅

## 殖民与战争：任务影响了不止一个人（creep）
